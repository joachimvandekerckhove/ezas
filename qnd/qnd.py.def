#!/usr/bin/env python3

import sys
import os
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '../../..')))

import numpy as np
from typing import Tuple, List
from vendor.ezas.base import ez_equations as ez
from vendor.ezas.classes.moments import Observations
from vendor.ezas.classes.parameters import Parameters
from vendor.ezas.classes.design_matrix import DesignMatrix
import unittest
import time
import argparse
from tqdm import tqdm
import copy

"""
Quick and dirty parameter estimation
"""
def qnd_single_parameter_estimation(
    observations: Observations, 
    n_repetitions: int = 1000
) -> tuple[Parameters, Parameters, Parameters, Parameters]:
    """Estimate EZ-diffusion parameters with uncertainty given observed statistics.
    
    Args:
        observations: Observed summary statistics (Observations)
        n_repetitions: Number of repetitions
    Returns:
        - mean_params: mean of Parameters (as a Parameters object)
        - std_params: std of Parameters (as a Parameters object)
        - lower_quantile_params: lower quantile of Parameters (as a Parameters object)
        - upper_quantile_params: upper quantile of Parameters (as a Parameters object)
    """
    if not isinstance(observations, Observations):
        raise TypeError("observations must be of type Observations")
        
    # Initialize the parameter matrix (K x 1 list of Parameters)
    parameter_matrix = [
        ez.inverse_equations(observations.resample().to_moments())
        for _ in range(n_repetitions)
    ]
    # Collapse to mean/std using Parameters.mean/std
    mean_params = Parameters.mean(parameter_matrix)
    std_params = Parameters.std(parameter_matrix)
    lower_quantile = 0.025
    upper_quantile = 0.975
    lower_quantile_params = Parameters.quantile(parameter_matrix, lower_quantile)
    upper_quantile_params = Parameters.quantile(parameter_matrix, upper_quantile)
    
    return mean_params, std_params, lower_quantile_params, upper_quantile_params

"""
Demonstrate basic QND parameter estimation
"""
def demonstrate_qnd_single_parameter_estimation(true_parameters: Parameters, sample_size: int):
    """Demonstrate basic QND parameter estimation.
    
    Args:
        true_parameters: True parameters (Parameters)
        sample_size: Number of trials used to generate the statistics (int)
    """
    # Generate some random parameters
    predicted_summary_statistics = ez.forward_equations(true_parameters)
    observed_summary_statistics = predicted_summary_statistics.sample(sample_size)
    
    # Estimate the parameters and time the operation
    start_time = time.time()
    (qnd_parameters_mean, 
     qnd_parameters_std, 
     lower_quantile_params, 
     upper_quantile_params) = qnd_single_parameter_estimation(observed_summary_statistics, n_repetitions=1000)
    end_time = time.time()
    
    # Write report to console
    report = f"""#### Sample size: {sample_size}
     > Predicted statistics  : {predicted_summary_statistics}
     > Observed statistics   : {observed_summary_statistics}
     > True parameters       : {true_parameters}
     > QND parameters (mean) : {qnd_parameters_mean}
     > QND parameters (sdev) : {qnd_parameters_std}
     > QND parameters (lower): {lower_quantile_params}
     > QND parameters (upper): {upper_quantile_params}
     > Time taken            : {(end_time - start_time):.2f} seconds
    """
    print(report)

"""
Simulation study for basic QND parameter estimation
"""
def qnd_single_parameter_simulation_study(
    true_parameters: Parameters, 
    sample_size: int, 
    simulation_repetitions: int):
    
    # Initialize a progress bar
    progress_bar = tqdm(total=simulation_repetitions, desc="Simulation progress")

    boundary_coverage = 0
    drift_coverage = 0
    ndt_coverage = 0
    total_coverage = 0
        
    for _ in range(simulation_repetitions):
        predicted_summary_statistics = ez.forward_equations(true_parameters)
        observed_summary_statistics = predicted_summary_statistics.sample(sample_size)
        (qnd_parameters_mean, 
         qnd_parameters_std, 
         lower_quantile_params, 
         upper_quantile_params) = qnd_single_parameter_estimation(observed_summary_statistics, n_repetitions=1000)
        
        boundary_covered = true_parameters.boundary >= lower_quantile_params.boundary and \
            true_parameters.boundary <= upper_quantile_params.boundary
        
        drift_covered = true_parameters.drift >= lower_quantile_params.drift and \
            true_parameters.drift <= upper_quantile_params.drift
        
        ndt_covered = true_parameters.ndt >= lower_quantile_params.ndt and \
            true_parameters.ndt <= upper_quantile_params.ndt
        
        if boundary_covered:
            boundary_coverage += 1
            
        if drift_covered:
            drift_coverage += 1
            
        if ndt_covered:
            ndt_coverage += 1
            
        if boundary_covered and drift_covered and ndt_covered:
            total_coverage += 1
            
        # Update the progress bar
        progress_bar.update(1)
        
    # Close the progress bar
    progress_bar.close()
            
    print("Coverage:")
    print(f" > Boundary: {boundary_coverage / simulation_repetitions}")
    print(f" > Drift   : {drift_coverage / simulation_repetitions}")
    print(f" > NDT     : {ndt_coverage / simulation_repetitions}")
    print(f" > Total   : {total_coverage / simulation_repetitions}")




"""
Quick and dirty parameter estimation of beta weights
"""
def qnd_multiple_parameter_estimation_beta_weights(
    observations: list[Observations],
    design_matrix: DesignMatrix
) -> DesignMatrix:
    """Estimate EZ-diffusion parameters with uncertainty given observed statistics and design matrices.
    
    Args:
        observations: Observed summary statistics (Observations)
        design_matrix: Design matrix for parameter estimation (n_conditions x n_parameters)
    Returns:
        - The updated design matrix with the beta weights
    """
    
    # Deep copy the design matrix
    local_matrix = copy.deepcopy(design_matrix)

    # Inject the observed summary statistics into the design matrix
    local_matrix.set_boundary([s.boundary() for s in observations])
    local_matrix.set_drift([s.drift() for s in observations])
    local_matrix.set_ndt([s.ndt() for s in observations])
    
    # Estimate the parameters
    local_matrix.fix()
    
    return local_matrix

def demonstrate_qnd_parameter_estimation_beta_weights(
    design_matrix: DesignMatrix,
    sample_sizes: list[int],
    n_repetitions: int = 1000
):
    """Demonstrate basic QND parameter estimation with beta weights.
    
    Args:
        design_matrix: Design matrix for parameter estimation (n_conditions x n_parameters)
        sample_sizes: List of sample sizes to use for parameter estimation (list of ints)
        n_repetitions: Number of repetitions
    """
    
    true_boundary_weights = design_matrix.boundary_weights()
    true_drift_weights    = design_matrix.drift_weights()
    true_ndt_weights      = design_matrix.ndt_weights()
    
    working_matrix = DesignMatrix(
        boundary_design = design_matrix.boundary_design(),
        drift_design    = design_matrix.drift_design(),
        ndt_design      = design_matrix.ndt_design(),
        boundary = design_matrix.boundary(),
        drift    = design_matrix.drift(),
        ndt      = design_matrix.ndt()
    )    
    print(working_matrix.boundary_design())
    print(working_matrix.drift_design())
    print(working_matrix.ndt_design())
    print(working_matrix.boundary())
    print(working_matrix.drift())
    print(working_matrix.ndt())
    print(working_matrix.boundary_weights())
    print(working_matrix.drift_weights())
    print(working_matrix.ndt_weights())
    
    estimated_boundary_weights = []
    estimated_drift_weights    = []
    estimated_ndt_weights      = []
        
    for _ in range(n_repetitions):
        working_matrix.resample(sample_sizes)
        
        estimated_boundary_weights.append(working_matrix.boundary_weights())
        estimated_drift_weights.append(working_matrix.drift_weights())
        estimated_ndt_weights.append(working_matrix.ndt_weights())
    
    # Compute mean and std and quantiles of the estimated weights
    
    lower_quantile = 0.025
    upper_quantile = 0.975
    
    mean_boundary_weights = np.mean(estimated_boundary_weights, axis=0)
    mean_drift_weights    = np.mean(estimated_drift_weights, axis=0)
    mean_ndt_weights      = np.mean(estimated_ndt_weights, axis=0)
    std_boundary_weights  = np.std(estimated_boundary_weights, axis=0)
    std_drift_weights     = np.std(estimated_drift_weights, axis=0)
    std_ndt_weights       = np.std(estimated_ndt_weights, axis=0)
    lower_quantile_boundary_weights = np.quantile(estimated_boundary_weights, lower_quantile, axis=0)
    upper_quantile_boundary_weights = np.quantile(estimated_boundary_weights, upper_quantile, axis=0)
    lower_quantile_drift_weights = np.quantile(estimated_drift_weights, lower_quantile, axis=0)
    upper_quantile_drift_weights = np.quantile(estimated_drift_weights, upper_quantile, axis=0)
    lower_quantile_ndt_weights = np.quantile(estimated_ndt_weights, lower_quantile, axis=0)
    upper_quantile_ndt_weights = np.quantile(estimated_ndt_weights, upper_quantile, axis=0)
    
    # Write report to console
    report = f"""#### Sample sizes: {sample_sizes}
     > True weights:
     > Boundary: {true_boundary_weights}
     > Drift   : {true_drift_weights}
     > NDT     : {true_ndt_weights}
     > Estimated weights:
     > Boundary: {mean_boundary_weights}
     > Drift   : {mean_drift_weights}
     > NDT     : {mean_ndt_weights}
     > Standard deviations:
     > Boundary: {std_boundary_weights}
     > Drift   : {std_drift_weights}
     > NDT     : {std_ndt_weights}
     > Quantiles:
     > Boundary: {lower_quantile_boundary_weights} - {upper_quantile_boundary_weights}
     > Drift   : {lower_quantile_drift_weights} - {upper_quantile_drift_weights}
     > NDT     : {lower_quantile_ndt_weights} - {upper_quantile_ndt_weights}
    """
    print(report)
    
    return mean_boundary_weights, mean_drift_weights, mean_ndt_weights, \
        std_boundary_weights, std_drift_weights, std_ndt_weights, \
        lower_quantile_boundary_weights, upper_quantile_boundary_weights, \
        lower_quantile_drift_weights, upper_quantile_drift_weights, \
        lower_quantile_ndt_weights, upper_quantile_ndt_weights

def qnd_multiple_parameter_estimation_design_matrix(
    observations: list[Observations], 
    design_matrix: DesignMatrix,
    n_repetitions: int = 1000
) -> tuple[Parameters, Parameters, Parameters, Parameters]:
    """Estimate EZ-diffusion parameters with uncertainty given observed statistics and design matrices.

    Args:
        observations: Observed summary statistics (Observations)
        design_matrix: Design matrix for parameter estimation (n_conditions x n_parameters)
        n_repetitions: Number of repetitions
    Returns:
        - mean_params: mean of Parameters (as a Parameters object)
        - std_params: std of Parameters (as a Parameters object)
        - lower_quantile_params: lower quantile of Parameters (as a Parameters object)
        - upper_quantile_params: upper quantile of Parameters (as a Parameters object)
    """
    if not isinstance(observations, list):
        raise TypeError("observations must be a list of Observations")
        
    # Initialize the parameter matrix (K x 1 list of Parameters)
    parameter_matrix = [
        [
            ez.inverse_equations(o.resample().to_moments()) for o in observations
        ]
        for _ in range(n_repetitions)
    ]
    # Collapse to mean/std using Parameters.mean/std
    mean_params = Parameters.mean(parameter_matrix)
    std_params = Parameters.std(parameter_matrix)
    lower_quantile = 0.025
    upper_quantile = 0.975
    lower_quantile_params = Parameters.quantile(parameter_matrix, lower_quantile)
    upper_quantile_params = Parameters.quantile(parameter_matrix, upper_quantile)
    
    return mean_params, std_params, lower_quantile_params, upper_quantile_params

"""
Demonstrate basic QND parameter estimation
"""
def demonstrate_qnd_single_parameter_estimation(true_parameters: Parameters, sample_size: int):
    # Generate some random parameters
    predicted_summary_statistics = ez.forward_equations(true_parameters)
    observed_summary_statistics = predicted_summary_statistics.sample(sample_size)
    
    # Estimate the parameters and time the operation
    start_time = time.time()
    (qnd_parameters_mean, 
     qnd_parameters_std, 
     lower_quantile_params, 
     upper_quantile_params) = qnd_single_parameter_estimation(observed_summary_statistics, n_repetitions=1000)
    end_time = time.time()
    
    # Write report to console
    report = f"""#### Sample size: {sample_size}
     > Predicted statistics  : {predicted_summary_statistics}
     > Observed statistics   : {observed_summary_statistics}
     > True parameters       : {true_parameters}
     > QND parameters (mean) : {qnd_parameters_mean}
     > QND parameters (sdev) : {qnd_parameters_std}
     > QND parameters (lower): {lower_quantile_params}
     > QND parameters (upper): {upper_quantile_params}
     > Time taken            : {(end_time - start_time):.6f} seconds
    """
    print(report)

"""
Simulation study for basic QND parameter estimation
"""
def qnd_single_parameter_simulation_study(true_parameters: Parameters, sample_size: int, simulation_repetitions: int):
    
    # Initialize a progress bar
    progress_bar = tqdm(total=simulation_repetitions, desc="Simulation progress")

    boundary_coverage = 0
    drift_coverage = 0
    ndt_coverage = 0
    total_coverage = 0
        
    for _ in range(simulation_repetitions):
        predicted_summary_statistics = ez.forward_equations(true_parameters)
        observed_summary_statistics = predicted_summary_statistics.sample(sample_size)
        (qnd_parameters_mean, 
         qnd_parameters_std, 
         lower_quantile_params, 
         upper_quantile_params) = qnd_single_parameter_estimation(observed_summary_statistics, n_repetitions=1000)
        
        boundary_covered = true_parameters.boundary >= lower_quantile_params.boundary and \
            true_parameters.boundary <= upper_quantile_params.boundary
        
        drift_covered = true_parameters.drift >= lower_quantile_params.drift and \
            true_parameters.drift <= upper_quantile_params.drift
        
        ndt_covered = true_parameters.ndt >= lower_quantile_params.ndt and \
            true_parameters.ndt <= upper_quantile_params.ndt
        
        if boundary_covered:
            boundary_coverage += 1
            
        if drift_covered:
            drift_coverage += 1
            
        if ndt_covered:
            ndt_coverage += 1
            
        if boundary_covered and drift_covered and ndt_covered:
            total_coverage += 1
            
        # Update the progress bar
        progress_bar.update(1)
        
    # Close the progress bar
    progress_bar.close()
            
    print("Coverage:")
    print(f" > Boundary: {boundary_coverage / simulation_repetitions}")
    print(f" > Drift   : {drift_coverage / simulation_repetitions}")
    print(f" > NDT     : {ndt_coverage / simulation_repetitions}")
    print(f" > Total   : {total_coverage / simulation_repetitions}")




"""
Test suite
"""
class TestSuite(unittest.TestCase):
    def test(self):
        pass


if __name__ == "__main__":
    
    parser = argparse.ArgumentParser()  
    
    parser.add_argument("--test", action="store_true", help="Run the test suite")
    parser.add_argument("--demo", action="store_true", help="Run the demo")
    parser.add_argument("--simulation-basic", action="store_true", help="Run the simulation")
    parser.add_argument("--simulation-design-matrix", action="store_true", help="Run the simulation with design matrix")
    
    args = parser.parse_args()
    
    if args.test:
        print("Running test suite...")
        unittest.main(argv=[__file__], verbosity=0, failfast=True)
        
    if args.demo:
        print("Running demo...")
        demonstrate_qnd_single_parameter_estimation(
            true_parameters = Parameters(1.0, 0.5, 0.2), 
            sample_size = 10)
        demonstrate_qnd_single_parameter_estimation(
            true_parameters = Parameters(1.0, 0.5, 0.2), 
            sample_size = 100)
        demonstrate_qnd_single_parameter_estimation(
            true_parameters = Parameters(1.0, 0.5, 0.2), 
            sample_size = 1000)
        
    if args.simulation_basic:
        print("Running simulation...")
        qnd_single_parameter_simulation_study(
            true_parameters = Parameters(1.0, 0.5, 0.2), 
            sample_size = 100, 
            simulation_repetitions = 1000)

    if args.simulation_design_matrix:
        print("Running simulation with design matrix...")
        qnd_multiple_parameter_estimation_design_matrix(
            true_parameters = Parameters(1.0, 0.5, 0.2), 
            sample_size = 100, 
            simulation_repetitions = 10000)

        design_matrix = DesignMatrix(
            boundary_design = np.array([[1, 0, 0], 
                                        [0, 1, 0], 
                                        [0, 0, 1], 
                                        [0, 0, 1]]),
            drift_design    = np.array([[1, 0, 0], 
                                        [0, 1, 0], 
                                        [0, 0, 1], 
                                        [0, 1, 0]]),
            ndt_design      = np.array([[1, 0, 0], 
                                        [0, 1, 0], 
                                        [0, 0, 1], 
                                        [1, 0, 0]]),
            boundary_weights = np.array([1.0, 1.5, 2.0]),
            drift_weights    = np.array([0.4, 0.8, 1.2]),
            ndt_weights      = np.array([0.2, 0.3, 0.4])
            )
        demonstrate_qnd_parameter_estimation_beta_weights(
            design_matrix = design_matrix,
            sample_sizes = [100, 200, 300, 400],
            n_repetitions = 1000)




"""
QND design matrix parameter estimation
"""
def qnd_design_matrix_parameter_estimation(
    obs_stats: List[Observations], 
    design_matrix: DesignMatrix
) -> Tuple[List[Parameters], List[Parameters]]:
    """Estimate EZ-diffusion parameters with uncertainty given observed statistics and design matrices.
    Args:
        obs_stats: Observed summary statistics (array of Observations)
        design_matrix: Design matrix for parameter estimation (n_conditions x n_parameters)
    Returns:
        Tuple containing:
        - Estimated parameters (Parameters)
        - Standard deviation of the parameters (Parameters)
    """
    if not (isinstance(obs_stats, list) and all(isinstance(x, Observations) for x in obs_stats)):
        raise TypeError("obs_stats must be a list of Observations")
    
    # Use the inverse equations to get quick and dirty estimates of the parameters
    qnd_params = ez.inverse_equations(obs_stats)
    
    # Initialize the parameter matrix
    parameter_list = []
    for _ in range(1000):
        resampled_obs_stats = [o.resample() for o in obs_stats]
        resampled_qnd_params = ez.inverse_equations(resampled_obs_stats)
        parameter_list.append(resampled_qnd_params)
    
    # Get the mean of the parameters
    mean_params = Parameters.mean(parameter_list)
    
    # Get the standard deviation of the parameters
    std_params = Parameters.std(parameter_list)
    
    # Return the mean and standard deviation of the parameters
    return mean_params, std_params, qnd_params
    
    
    # Resample the observed statistics 1000 times
    for _ in range(1000):
        resampled_obs_stats = [sample_statistics(o, n) for o, n in zip(obs_stats, N)]
        design_matrix = qnd_parameter_estimation(resampled_obs_stats, N, boundary_design, drift_design, ndt_design)
        dmx.append(design_matrix)
        
    # Get mean and variances from list of design matrixes
    mean_boundary_weights = np.mean([d.boundary_weights() for d in dmx], axis=0)
    mean_drift_weights    = np.mean([d.drift_weights() for d in dmx], axis=0)
    mean_ndt_weights      = np.mean([d.ndt_weights() for d in dmx], axis=0)
    std_boundary_weights  = np.std([d.boundary_weights() for d in dmx], axis=0)
    std_drift_weights     = np.std([d.drift_weights() for d in dmx], axis=0)
    std_ndt_weights       = np.std([d.ndt_weights() for d in dmx], axis=0)
    
    return (mean_boundary_weights, mean_drift_weights, mean_ndt_weights,
            std_boundary_weights, std_drift_weights, std_ndt_weights)